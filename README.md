## Понимание JVM

Для исследования был предложен следующий код:

```java
public class JvmComprehension {

    public static void main(String[] args) {  // 0
        int i = 1;                      // 1
        Object o = new Object();        // 2
        Integer ii = 2;                 // 3
        printAll(o, i, ii);             // 4
        System.out.println("finished"); // 7
    } // 8

    private static void printAll(Object o, int i, Integer ii) { // 4.1
        Integer uselessVar = 700;                   // 5
        System.out.println(o.toString() + i + ii);  // 6
    } // 6.1
}
```

До того как начнется выполнение программы произойдет несколько шагов по подготовке работы JVM.

#### Стадия загрузки JVM:

- Операционная система выполняет старт JVM.
- Выделяется память для Stack, Heap и Metaspace.
- Создается нативный **Bootstrap Class Loader**, который будет загружать базовые классы JRE, например из пакетов `java.*` (`jre/lib/rt.jar`).
  - На этой стадии будет загружен и проициализирован объект `java.lang.System` и связанные с ним классы типа `PrintWriter` для `System.out`.
- Создается **Extension Class Loader**, который занимается загрузкой расширений (`jre/lib/ext`).
- Создается **Platform Class Loader**, которому передается путь `classpath`.
- Создается **Application Class Loader**, который будет загружать пользовательские классы и нашу программу.

> Загрузчики классов имеют иерархию. Если класс или ресурс не найден, то запрос на загрузку будет переназначен родительскому загрузчику.

#### Стадия загрузки классов:

- Application Class Loader **загружает** байткод класса `JvmComprehension`.
  - Выполняется **проверка**. Например наличие заголовка 0xCAFEBABE и возможность исполнения этой версии байткода на текущей версии JVM.
  - После загрузки класса `JvmComprehension` проверяется доступность **связанных** классов в полях и методах.
    Будут получены ссылки на классы `System`, `String`, `Object`, `Integer` т.к. они участвуют в описании методов.
  - Класс успешно загружен в `MetaSpace` и становится доступен интерпретатору.

#### Запуск программы:

  - Интерпретатор получил название класса для выполнения и ищет в нем публичную статичную функцию `main(String[])`.
  - Если функция найдена, то начинается исполнение.
  
#### Строка 0: Запуск функции `main()` new [main]

- В стеке создается новый фрейм функции `main()`.
  - Если в командной строке были переданы аргументы, то во фрейм добавляется ссылка `args` на массив `String[]` в куче.

#### Строка 1: `int i = 1;` [main]

- Во фрейм `main()` добавлено значение `int i = 1`

#### Строка 2: `Object o = new Object();` [main]

- В куче создан `new Object()`[01:Object].
- Во фрейм `main()` добавлена ссылка `Object o` = [01:Object]

#### Строка 3: `Integer ii = 2;` [main]

- В куче должен быть создан `new Integer(2)`. Но сработает оптимизация и мы получим объект из пула [02:Integer]
- Во фрейм `main()` добавлена ссылка `Integer ii` = [02:Integer]

#### Строка 4: `printAll(o, i, ii);` [main]

- В стек добавлены аргументы для вызова функции:
  - ссылка на [01:Object]
  - значение 1:int
  - ссылка на [02:Integer]
- Вызов метода `printAll([01:Object], 1:int, [02:Integer])` заберет из стека аргументы и передаст управление

#### Строка 4.1: `printAll(Object o, int i, Integer ii)` [main]->new [printAll]
  
  - В стеке создан новый фрейм `printAll()`
  - Добавлена ссылка `Object o` = [01:Object]
  - Добавлено значение `int i = 1`
  - Добавлена ссылка `Integer ii` = [02:Integer]

#### Строка 5: `Integer uselessVar = 700;` [main]->[printAll]

- В куче создан `new Integer(700)` [03:Integer]
- Во фрейм `printAll()` добавлена ссылка `Integer uselessVar` = [03:Integer]

> Так как объект нигде не используется, то при оптимизации компилятором он может быть выброшен из кода.

#### Строка 6: `System.out.println(o.toString() + i + ii);` [main]->[printAll]

> Начиная с Java 9 конкатенация строк не проводится напрямую через StringBuilder. Для будущих оптимизаций используются `invokedynamic` вызовы к `java.lang.invoke.StringConcatFactory`. Для наглядности описывается старый метод и пропускаются шаги создания фреймов стека для вызова системных методов.
>
> (JEP 280: Indify String Concatenation)[https://openjdk.org/jeps/280]

- Подготовка к вызову `System.out.println(String x)`:
  - Подготовка к конкатенации:
    - В куче создан `new StringBuilder()` [04:StringBuilder]
    - Во фрейме создана анонимная ссылка [04:StringBuilder]
    - Отображение объектов в символьной форме:
      - Получение `o.toString()`:
        - Вызывается метод `[01:Object].toString()`, результат [05:String] заносится в кучу.
        - Во фрейм помещена анонимная ссылка [05:String]
      - Вызов метода `[04:StringBuilder].append([05:String])`
      - Получение `i`:
        - Вызывается метод `String.valueOf(int)`, результат [06:String] заносится в кучу.
        - Во фрейм помещена анонимная ссылка [06:String]
      - Вызов метода `[04:StringBuilder].append([06:String])`
      - Получение `ii`:
        - Вызывается метод `[02:Integer].toString()`, результат [07:String] заносится в кучу.
        - Во фрейм помещена анонимная ссылка [07:String]
      - Вызов метода `[04:StringBuilder].append([07:String])`
  - Вызов метода `[04:StringBuilder].toString()`, результат [08:String] помещен в кучу.
  - Во фрейм помещена анонимная ссылка [08:String] с результатом конкатенации.
- Получена анонимная ссылка на объект `System.out` [sys:PrintWriter]
- Вызов метода `[sys:PrintWriter].println([08:String])`
  - Вывод на экран текста из [08:String], вида `java.lang.Object@43a2584812`. Где последние символы соответствуют `1`= i:int, `2`=ii:Integer

#### Строка 6.1: [main]->[printAll]

- Происходит завершение метода
  - Удаляется фрейм `printAll()`:
    - Удаляются ссылки вместе с значениями переменных:
      - Object o, int i, Integer ii, Integer uselessVar
    - Следующие объекты в куче потеряют жесткие ссылки и станут доступны сборщику мусора:
      - [03:Integer], [04:StringBuilder], [05:String], [06:String], [07:String], [08:String]
    - В блоке main() еще остаются ссылки на объекты [01:Object] и [02:Integer], поэтому сборщик мусора не сможет их удалить после завершения printAll().
- Метод ничего не возвращает, новых записей во фрейме `main()` не появится
  
#### Строка 7: `System.out.println("finished");` [main]

- Получена анонимная ссылка на объект [sys:PrintWriter]
- Если в пуле строк нет такой записи, то в куче будет создан `new String("finished")` [09:String].
- Во фрейм помещена анонимная ссылка [09:String]
- Вызов метода `[sys:PrintWriter].println([09:String])`
  - Вывод на экран текста `finished` из [09:String].
  - Метод ничего не возвращает.

#### Строка 8: [main]

- В стеке находится фрейм `main()`. Он содержит:
  - ссылку на аргументы `String[] args`
  - значение `int i = 1`
  - ссылку `Object o` = [Object:01] (куча)
  - ссылку `Integer ii` = [02:Integer] (кэш Integer)
  - анонимную ссылку `System.out` [sys:PrintWriter]

- Удаляется фрейм `main()`:
  - Очищены ссылки и значения `String[] args`, `int i`, `Object o`, `Integer ii`
    - Соответствующие объекты в куче станут доступны сборщику мусора
  - Удалена анонимная ссылка `System.out` но объект [sys:PrintWriter] является общим и системным для среды выполнения.

#### Завершение программы: []

- Стек пуст, выполнять нечего.
- JVM очищает использованные ресурсы и возвращает их операционной системе
  - память под стек, кучу и Metaspace
  - освобождаются использованные системные дескрипторы
  - завершаются потоки
- Программа успешно завершена и возвращает операционной системе код `0`

